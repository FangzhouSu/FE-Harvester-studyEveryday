# 北京字节跳动技术中台日常实习一面 21/11/19

> 估计是跪在算法题上了，easy级别的题没A出来，算法思路是正确的（面试官说得）但是代码写得太丑陋了（我自己说得）
>
> 面试官大大很和善~一直跟我说别这么客气，叫同学就行😂
>
> 这次面试整体难度真的很小！可能是因为看我学习时间只有三个多月的缘故吧XD（之前看面经也没见过这么简单的）

上来先是根据自我介绍关于学习路线/简历上关于专业课（数据挖掘、强化学习）问了下为啥不继续搞人工智能了XD

答：不太感兴趣（总之就是这个意思 巴拉巴拉把往事说了一下XD）

## 聊项目

接手的外包项目刚做了三周不到，所以问得不深。

- 你在这个大型项目中主要负责什么
- 一些交互的效果是如何做出来的
- 看项目是交通相关的，能不能说一下路口信息如何更新到组件中

[JS30demos项目](https://github.com/FangzhouSu/JS-30Demos) 问了一句

- 如何想到做这个项目的呢

答 为了巩固下JS基础，感觉比较重要 然后没有细问

## 计算机网络

#### 了解HTTPS么？说一下HTTPS的一个传输过程

- 非对称加密建立HTTPS连接
- 然后使用对称加密进行报文的收发

![image-20211111123546328](https://gitee.com/su-fangzhou/blog-image/raw/master/202111111235564.png)

##### 追问-说一下非对称加密是如何利用公钥私钥解决安全问题的（之前第一问里有挖坑）

当时答得有点乱，下来整理了一下，感觉清晰不少~

> 另外搜索非对称算法时，网上好多文章没说的一点就是这个非对称算法是用来干啥的，根据图解HTTP的内容，我的理解是以下几个步骤：
>
> - 【1】客户端有私钥A + 公钥A； 服务器有私钥B + 公钥B
> - 【2】规则——私钥A+公钥A = 密钥对A（公钥A加密的内容只有私钥A可以解密！）
> - 【3】为了建立安全的通信道路（不被坏人篡改、冒名顶替（窃听就木有办法辣，不过也不怕！我们这个是非对称加密！被窃听了也不会被破解的）），客户端把手里的公钥发送给服务器
> - 【4】服务器使用拿到的公钥A进行**重要报文**（也就是图解HTTP提到的 “**稍后的共享密钥加密中要使用的密钥**”）的加密，之后再发给客户端
> - 【5】客户端手里有私钥A，直接解密这个**重要报文**，安全地获得共享密钥！妙啊！
>
> 这样互联网上的不法分子就没辙辣！
>
> > 另外还可以使用数字证书解决公开密钥的传输问题 - 图解HTTP很香啊！
> >
> > ![image-20211111123455666](https://gitee.com/su-fangzhou/blog-image/raw/master/202111111234902.png)



## JS基础

#### 说下JS有哪些数据类型？

Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。

#### 那引用数据类型和原始数据类型有什么区别么？

- 栈：原始数据类型（Undefined、Null、Boolean、Number、String）
- 堆：引用数据类型（对象、数组和函数）

两种类型的区别在于**存储位置的不同：**

- 原始数据类型直接存储在栈（stack）中的简单数据段
  - 占据空间小、大小固定
  - 属于被频繁使用数据，所以放入栈中存储；
- 引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。
  - 如果存储在栈中，将会影响程序运行的性能；
  - 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。
  - 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。

#### 说一下new一个构造函数过程中发生了什么

> 艾玛太经典了，我还写过[一篇文章](https://juejin.cn/post/7012887169878458404)说这里哩

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f493f86148bf4a3c888e34b6f6fd79c1~tplv-k3u1fbpfcp-watermark.awebp?)

说了一下 在红宝书看到过bulabulabula

另外拓展了一下——判断构造函数的返回值类型，如果res为对象类型，new Person的最终结果为res 而非我们想要的那个实例对象！

##### 追问-刚才说的第三步提到了this，那么new过以后，this指向哪里呢？

指向这个新创建的对象（红宝书提到了）

> 拓展：可以看看之前写的那篇文章中的例子 Fn即为构造函数 很明显它是指向这个新创建的Object空对象的
>
> ![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09b2a3006d514261b9a8f1638d277c3e~tplv-k3u1fbpfcp-watermark.awebp)

## 浏览器原理

> 这里被问了蛮多的~可能也是因为我在第一个问题的时候说得内容（挖的坑）太多吧！

####  浏览器的渲染过程

【1】解析 HTML 构建DOM树

【2】解析CSS 构建CSSOM树

【3】利用上面两个树构建渲染树（渲染树的节点即为“渲染对象”）

【4】渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以被称作“**回流**”）这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“**自动重排**”。

【5】上述几步过后，布局结束；最后进行绘制，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。

记住这张图：

![image](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603797939165-3bf54e28-5469-4093-a0e1-e0569cec1305.png)

> 完整过程中的一些细节——
>
> - 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。
> - 然后对 CSS 进行解析，生成 CSSOM 规则树。
> - 根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。
> - 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行**布局**（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。
> - 布局阶段结束后是**绘制**阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。

##### 追问-解析文档（HTML）过程中，是将HTML都解析完了再去生成渲染树麽？

**注意：**这个过程是逐步完成的，**为了更好的用户体验**，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。

##### 追问-script中的脚本文件、link中的css文件的解析/执行会阻塞文档解析麽？如何阻塞？

- 脚本的加载会阻塞文档解析

如果没有 defer 或 async 属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。

下图可以直观的看出三者之间的区别:

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603547262709-5029c4e4-42f5-4fd4-bcbb-c0e0e3a40f5a.png)

所以**script要放在底部/加async defer关键字**

> 拓展学习：
>
> JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，**将控制权移交给 JavaScript 引擎**，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。
>
> 也就是说，如果想要首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都**建议将 script 标签放在 body 标签底部的原因**。
>
> - 当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。

- CSS 如何阻塞文档解析？

**理论上**，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们。

> 面试官也提到了这里，CSS的解析并不阻塞文档~
>
> - 但是可以拓展一下，JS的脚本会因为CSSOM树没被构建好而延迟执行，所以！要**把script放在底部/加async defer关键字**

然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中**请求样式信息**（比如根据样式获取元素节点），如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以——

**如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本**，那么浏览器将**延迟 JavaScript 脚本执行和文档的解析**，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。这样就会间接阻塞了文档解析

##### 追问-什么情况会阻止浏览器渲染

前面问的细节，这个问题比较全面了就

要明确——首先**渲染的前提是生成渲染树**

- 所以 HTML 和 CSS 肯定会阻塞渲染。

> 如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。

- 浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。

> 也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。

> 拓展知识
>
> 并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性
>
> - 当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后**顺序执行**，所以对于这种情况你可以把 script 标签放在任意位置。
> - 同理，对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染（async属性**不能保证JS文件的执行是按顺序的**~）。

记住下面这个图就好~

> ![image.png](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603547262709-5029c4e4-42f5-4fd4-bcbb-c0e0e3a40f5a.png)
>
> 蓝色代表 js 脚本网络加载时间，红色代表 js 脚本执行时间，绿色代表 html 解析

## 框架

#### 说下Vue中的key有啥用？

> 这个因为Vue没咋学过，说得比较模糊，但是结合之前学习React残留下来的一点记忆强答了一波

官方文档——

> `key` 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。
>
> 有相同父元素的子元素必须有**独特的 key**。重复的 key 会造成渲染错误。

面试官给出解释——如果不用key的话，在列表增删的时候，渲染效率会出问题（和虚拟DOM有关）

但是如果key使用错误了，在列表顺序需要变更时，则容易发生顺序错误！

## 其他

#### 了解CDN麽？

听说过这个，在一些开源仓库的readme中一些资源是挂在cdn上的，比如图片和视频。

面试官说cdn是用来存储一些资源的类似服务器的东西，一些上线的项目会就近使用这其中的资源，比较快~

> CDN的全称是Content Delivery Network，即[内容分发网络](https://baike.baidu.com/item/内容分发网络/4034265)。
>
> CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的**边缘**服务器，通过**中心**平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，**降低网络拥塞，提高用户访问响应速度和命中率**。CDN的关键技术主要有内容存储和分发技术。 

## 算法题

#### 删除字符串-力扣easy中稍难一些的一题

> 与leetcode1047（利用栈可以巧妙解决）类似，但是要麻烦一些
>
> ![img](https://gitee.com/su-fangzhou/blog-image/raw/master/202111192256739.jpg)
>
> leetcode1047如下：
>
> ![image-20211119231003241](https://gitee.com/su-fangzhou/blog-image/raw/master/202111192310340.png)

- 想了一两分钟，先说思路，使用双指针挨个删除，面试官说可以，让我写代码

然后噩梦开始😂

几分钟吧大概代码就写好了，但是第一遍运行超时，就开始慌了。

**现在想想不应该慌，应该从头，从while循环（很明显是超时的罪魁祸首）一点点看！但是当时也是因为紧张，就瞎改一堆，越改越乱！反省！**

> 既然难以做到一遍AC，就应该建立起完整的找错体系！
>
> - 超时：找while循环是不是推出条件错了
> - 答案与结果不符合：把数据代入代码走一遍！

正确答案（自我反省）如下：

```js
/* 删除字符串中出现大于等于2的相邻字符 */
function removeDuplicates(str){
    let i = 0, j = 1;
    // 主要错误1：while(str[j] !== null) 链表写多了！！退出条件写成这样了我晕！主要就错这里了...还是有点慌
    while(str[j]){
        if(str[i] === str[j]){
            str = deleteStr(str, i, j);
            i = 0;
            j = 1;
        }
        else{
            i++;
            j++;
        }
    }
    return str;
}
function deleteStr(str, i, j){
    // 删除[i,j]范围内的字符串
    let start = i;
    let end;
    while(str[i] === str[j]){
        i++;
        j++;
    }
    end = i;
    // 主要错误2：删除字符串[i,j]范围内的数居然一时间忘记了！我晕！当时这么写的：str.split("").splice(start, end-start+1).join("")
    // 这根本改不掉字符串啊...当时我在想啥...
    	// 主要是超时我也不太好console.log()来debug，所以下回出现超时问题时第一时间把while那里的问题全弄掉！
    let arr = str.split("");
    arr.splice(start, end - start + 1)
    str = arr.join("");
    return str;
}
console.log(removeDuplicates("abbbaca"));// "ca"
```



# 北京字节跳动技术中台日常实习二面 21/11/26

> 上次是面经
>
> 这回是凉经哈哈
>
> - JS基础不行（考察了贼不熟悉，之前几乎没看过的Promise **凉**）
>
> - 稍微有些自信的计算机网络考了一个CDN的内容（真没用过QAQ **凉**），考了个HTTP缓存（只剩一点点印象了，就看到过一次这个概念orz，被深入追问搞懵 **凉**）
> - Vue框架内容本来没有系统学过（问双向绑定的具体实现，虽然是经典八股文，虽然说出来了Proxy代理，但是 我哪儿会啊 **凉**）
> - 算法题 超级经典 最大子序列和 用的贪心算法（经典思路对代码错，这么简单的代码都写不出来。。感觉当时脑子已经乱掉了😂 **凉**）
> - 问题不多，大部分时间都是面试官在指出我答题时的问题——没用甚至起到副作用的回答太多、答不到点子上、代码能力太弱！
>   - 虽然挺伤俺心但是真的挺有收获的！总而言之，感谢这位冷酷（雀氏有一些严肃）帅气（真的挺帅的）的哥哥！我会更加努力哒！
>
> 经验总结：
>
> **回答问题时要抓住重点，铺垫的背景可以不讲那么多，只要回答面试者想知道的（想要考察的）点即可！**不知道可以爽快地过/询问面试官正确答案进行进一步探讨？总之尽可能多地让自己会的知识点和自己的闪光点被面试官大大看到！

## 一面内容回顾

问到了一面时问过的 CDN内容分发网络、Vue中的key

考察面试之后是否有很好的总结

> 回答中废话太多且关键内容太浅！

从这里面试官大大就对我印象分- -了

上面说的“问题抓不住重点”就是出自这里

> 经验教训：之后总结一个知识点要加上“精炼版本的解答”——
>
> 遵循学习知识三段论
>
> - 了解这个知识的概念是什么
> - 了解这个知识被提出来的目的是什么?
> - 将知识用一句话（简练地）说清楚！

### 了解CDN内容分发网络嘛~说一下

> 开始我说了cdn是用来存储一些资源的类似服务器群体，一些上线的项目会就近使用这其中的资源，可以加速~
>
> 面试官大大这样批评我——“cdn能干啥不是我想问的，我想直到的是其中的细则”
>
> 菜是原罪呐QAQ

正确回答：

- CDN依靠部署在各地的==**边缘**服务器==，通过==**中心**平台==的负载均衡、内容分发、调度等功能模块，使用户**就近获取所需内容，降低网络拥塞**，提高用户访问响应速度和命中率。

- CDN的关键技术主要有内容存储和分发技术。 

- 最好能是使用过这个。

上面重点标注的==**边缘**服务器==，==**中心**平台==才是重点哈！

> “要结合实际应用去理解，而不是背知识点”
>
> 金句频出！（也是疯狂吊打我啊😂😂）

### Vue中的key有什么作用

又问到了这个知识点，很明显答案没让面试官大大满意XD

再来回忆一下官方文档吧！

- `key` 的特殊 attribute 主要**用在 Vue 的虚拟 DOM 算法**，**在新旧 nodes 对比时辨识 VNodes**。
  - 如果不使用 key，Vue 会使用一种**最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素**的算法。
  - 而使用 key 时，它会**基于 key 的变化重新排列元素顺序**，并且**会移除 key 不存在的元素**。

- 有相同父元素的子元素必须有**独特的 key**。重复的 key 会造成渲染错误。

效率上的问题看来是比较被看重的！学习的时候要多注意呐！

另外这里还是得多用，就能记住了~背知识点是不对的哩

## 计网

#### 说一下HTTP缓存的内容

答了本地磁盘缓存和浏览器缓存

> 下面追问的部分在小林Coding的《图解网络》中有说过，但是我只在很久前看过一遍..忘记了

##### 追问-说下本地磁盘缓存的细节呢

好久没看这块儿。。给忘掉了

##### 追问-了解浏览器缓存中的强缓存和协商缓存嘛

也是忘掉了。。

##### [http缓存详解，http缓存推荐方案](https://www.cnblogs.com/echolun/p/9419517.html)

这篇文章写得不错，推荐~

## JS知识考察

这里直接就手写代码了，开始问我了解Promise不~让写一个经典的`Promise.all()`，这东西…我只是听说过有从没实现过啊…就让面试官大大换一个，

### 实现sleep函数 

> 很多编程语言里都有`sleep()`，`delay()`等方法，它能让我们的程序不那么着急的去执行下一步操作，而是延迟、等待一段时间。

最开始用了个语法糖实现被告知不符合要求,需要自己封装一个sleep函数返回promise

```js
async function sleep() {
    await setTimeout(() => {
        console.log("wake u")
    }, 1000)
}
sleep(1000)
```

主要是对Promise封装不很了解。。这里开始有点懵，后来面试官大大很无奈地给了提示…（这么简单还需要我给提示嘛？面试官大大脸上写满了这句话 我太菜了…）

```js
function sleep(time) {
 	return new Promise(resolve => {
//        setTimeout(() => {
//            resolve()
//        }, time)
        setTimeout(resolve, time)// 这种写法更简单~
    })   
}
sleep(1000).then(() => console.log("wake up"))
```

## 算法题

#### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

可以暴力解，可以贪心，可以动归的一题

```js
// 1.使用的贪心算法，每轮记录当前的和temp
	// 01 当前和大于零则继续将下一个要遍历的值加到temp上	
	// 02 一旦当前和小于零则放弃当前的和temp，将下一个要遍历的值赋给当前的和temp
// 2.记录最大子序值，每轮进行更新
// 这么简单一个思路我不理解为啥我会写不出来正确代码？？！if else不会嘛？
var maxSubArray = function(nums) {
    let tempSum = nums[0]// 存储 现在的和
    let maxSum = nums[0]
    for(let i = 1; i < nums.length; i++) {
        if(tempSum < 0) {
            tempSum = nums[i]
        }
        else {
            tempSum += nums[i]
        }
        maxSum = maxSum > tempSum ? maxSum : tempSum
    }
    return maxSum
};
```



## 面试官大大给出的宝贵建议

> 大部分为面试官大佬的原话，少数进行艺术加工😂但是大体上就是这个意思

- 学好基础学科的内容——计算机网络、操作系统
- 学好前端基础——JavaScript
- 对框架要熟悉，要了解一些效率上的问题以及部分核心功能的原理（也就是常说的“读源码”）
- **多敲代码**
  - 你看到知识，背下来它，嗯背得很好，下次不要这样了。
  - 公司招实习生不是为了让你来学习的，而是要实现业务，比如说写一个跑马灯，写一个轮播图，要能写得出来啊，代码能力要强！
  - 学习过程中如果有想法就要**付诸实践**多去敲一敲代码，实现一些具体功能！多敲才能更熟练。

- 实现算法题时，如果对于高级解法没有特别多自信，那么可以选择先暴力求解A出来再去寻求好解法！
  - 有些想到的好想法不会具体实现可以不提或放在最后题，不要上来把自己的印象分扣光哈！
- 入职以后，为了更好的未来发展要关注软素质——如何让代码更优雅，更简洁~
